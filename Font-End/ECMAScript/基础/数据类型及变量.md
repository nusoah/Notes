## <font color=#161100 face="黑体">数据类型</font>

### 原始值

`number、string、boolean、undefined、null`

数字类型加上前缀表示不同进制

    0：var num = 010 表示八进制 8
    0x: var num = 0x10 表示16进制 16
    0b: var num = 0b10 表示二进制 2

字符串类型

    在字符串内使用特殊字符用转义字符: var str = ' hello 'world'
    \t: 制表符用于缩进
    \n：换行符用于换行

### 引用值

`object、function`

## 数据类型的判断

通常情况下判断数据的类型一般使用`typeof`关键字, 其返回值:

`"number"、"string"、"boolean"、"undefined"、"object"、"function"`

## 变量

变量：变量是一块内存空间，用于存储数据

    什么是内存？

    计算机组成：CPU、内存、硬盘、输入输出设备

    内存：读写速度快，易丢失

    硬盘：读写速度慢，数据持久化

    计算机程序的运行速度只与内存有关

**弱数据类型的语言的特点**: 在 js 中变量的类型是可以变化的, 上一秒是数字下一秒可能就会是字符串

**变量声明注意点**: 变量名只能以英文字母、\_、$开头,其他位置可以出现数字、英文字母、_、$

    变量的声明和赋值可以放在一条语句内书写，本质就是语法糖。

## <font color=#161100 face="黑体">变量与对象</font>

获取对象属性值

    对象名.属性名

修改对象属性值

    对象名.属性名 = 属性值

    eg: user.name = 'seo'，如果没有这个属性会自动赋值；

删除对象属性

    delete 对象名.属性名

```js
var user = {
  name: "steven",
};
console.log(user.name); // 'steven'
user.age = 19;
console.log(user); // { name: 'steven', age: 19 }
delete user.name;
console.log(user); // { age: 19 }
```

    当读取的属性不存在时，值为undfined

    当读取的对象不存在时，对象的值为（undfined或null）,报错

属性表达式

    对象名["属性名"] ，可读可写

适用场景: 属性名中包含特殊字符（不符合变量的命名规范时），如：

```js
var user = {
  "@3^&*_": "666",
};

// 只能使用[]访问
// user."@3^&*_" => 会报错

console.log(user["@3^&*_"]); // 666
```

在 JavaScript 中，对于属性的要求并不严格，属性名可以是任何形式的数据（`number、string、boolean、undefined、null、arrary、object`），但宿主环境最终都会转换为字符串（数组会解构，对象会直接调用 toString 方法）

```js
var user = {
  name: "steven",
};

// <!--方式1-->
user.true = 10;
console.log(user); // { name: 'steven', true: 10 }

// <!--方式2-->
user["true"] = 20;
console.log(user); // { name: 'steven', true: 20 }
```

数组和对象的转换方式略有不同

```js
var user = {
  name: "steven",
};
user[[1, 2, 3, 4]] = 10; //  数组
console.log(user); // { name: 'steven', '1,2,3,4': 10 }

user[{}] = 90; // 对象
console.log(user); //{ name: 'steven', '1,2,3,4': 10, '[object Object]': 90 }
```


```js
var obj = {};

obj[0] = 123; //  会转换为字符串

obj["0"] = 234;

console.log(obj[0], obj["0"]); // 234 234 二者本质相同,操作的是一个变量
```

## 全局对象


JS 的大部分宿主环境, 会提供一个特殊的对象, 在 JS 代码中可以直接访问,该对象被叫做全局对象,在浏览器环境中, 全局对象为 window, 表示整个浏览器窗口;

全局对象中所有属性可直接访问,不需要加上全局对象名.

```js
console.log(alert === window.alert); // true
```

在浏览器环境中,开发者定义的全局变量,都会成为 window 对象上的属性

```js
console.log(window.abs); // undefined => window没有abs属性

var abs = 0;

console.log(window.abs); // 0  window.abs可以访问到abs属性
```

如果 window 中有同名变量且开发者定义了的变量且赋值了,那么 window 中的同名变量被覆盖

```js
var alert = "123"; // window对象中有alert属性为函数

console.log(alert); // 123    window.alert被覆盖
```

如果 window 中有同名变量但开发者定义了的变量且没有赋值(只是声明了一个与 window 对象一个属性同名的变量), 则 window 中的属性不会被覆盖

```js
var alert;

console.log(window.alert); // ƒ alert() { [native code] }
```

window 上有一个 name 属性, 该属性是 window 自带的, 为一个空字符串, 并且无论给这个属性赋成什么值都会被转换为字符串

```js
console.log(name, typeof name); // '' 'string'

console.log(window.name === name); // true

var name = undefined;

console.log(window.name, typeof name); // 'undefined' 'string'
```

## 引用类型


变量赋值

```js
var a = "123";
var b = a;
b = "456";
console.log(a, b); // '123' '456'  ==> 不会改变

var obj1 = {
  name: "123",
};
var obj2 = obj1;
obj2.name = "456";
console.log(obj1.name, obj2.name); // '456' '456' ==> 会改变
```

**所有的变量赋值操作都是复制粘贴的过程**

- 对于原始值: 变量占用的内存直接存储数据值(在赋值操作中将占用的内存直接赋值给另一个变量, 二者变量的占用的内存空间存储的数据相同, 确属于不同的内存空间), 所以修改其中一个变量另一个不会改变;

- 对于引用值: 会占用两个内存空间, 一个是变量占用的空间用于存放指向引用值的地址, 另一个内存空间用于存放引用值真实值(在赋值操作中, 会将变量占用的内存空间赋值, 也就是存放地址的那个内存, 二者地址相同, 共同指向一个内存空间, 修改其中一个变量的属性另一个也会改变).

```js
var obj1 = {
  name: "sss",
};
var obj2 = obj1;
obj2 = {
  name: "111",
};
console.log(obj1.name, obj2.name); //sss 111
```

```js
var obj3 = {
  name: "sss",
  sub: {
    age: 10,
  },
};
var obj4 = obj3;
obj4.sub = {
  age: 100,
};
console.log(obj3.sub.age, obj4.sub.age); // 100 100
```

```js
var obj5 = {
  name: "sss",
  sub: {
    age: 10,
  },
};
var temp = obj5.sub;
var obj6 = obj5;
temp = {
  age: 100,
};
console.log(obj5.sub.age, obj6.sub.age); // 10 10
```

```js
var obj7 = {
  name: "sss",
  sub: {
    age: 10,
  },
};
var temp = obj7.sub;
var obj8 = obj7;
obj8.sub = {
  age: 100,
};
console.log(obj7.sub.age, obj8.sub.age, temp.age); // 100 100 10
```

## <font color=#161100 face="黑体">垃圾回收</font>

垃圾回收器会定期发现内存中无法访问到的对象, 该对象称为垃圾, 垃圾回收器会在合适的时机将其占用的内存释放.

```js
var obj = {
  name: "rubbish",
};
obj = {
  msg: "we will replace rubbish",
};
```

下面这条赋值语句执行之后, 上面的对象 `{name:'rubbish'} `变为垃圾(无法通过某个变量内的地址找到这个对象即为垃圾）.

![image](./assets/rubbish.png)

### 垃圾回收内部算法

基本的垃圾回收算法称为"标记-清除"，定期执行以下“垃圾回收”步骤:

    1. 垃圾回收器获取根,并‘标记’(记住)它们;
    2. 然后垃圾回收器访问并‘标记;所有来自根的引用;
    3. 垃圾回收器访问标记的对象并标记它们的引用,所有被访问的对象都被记住，以便以后不再访问同一个对象两次;
    4. 以此类推，直到有未访问的引用(可以从根访问)为止;
    5. 除标记的对象外，所有对象都被删除。

> 注：标记的是垃圾。

这就是垃圾收集的工作原理, JavaScript 引擎应用了许多优化 ,使其运行得更快, 并且不影响 JavaScript 执行.

### 垃圾回收优化

    - 分代回收——对象分为两组:"新对象"和"旧对象"。许多对象出现，完成它们的工作并迅速结，它们很快就会被清理干净。那些活得足够久的对象，会变"老"，并且很少接受检查。

    - 增量回收——如果有很多对象, 并且我们试图一次遍历并标记整个对象集, 那么可能会花费一些时间, 并在执行中会有一定的延迟.因此, 引擎试图将垃圾回收分解为多个部分.然后, 各个部分分别执行.这需要额外的标记来跟踪变化, 这样有很多微小的延迟, 而不是很大的延迟.

    - 空闲时间收集——垃圾回收器只在CPU空闲时运行, 以减少对执行的可能影响.

