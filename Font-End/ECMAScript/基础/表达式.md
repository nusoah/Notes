## <font color=#161100 face="黑体">表达式</font>

> 表达式 = 操作符 + 操作数

每一个表达式都有一个运算结果, 这个结果叫做 `返回值`，返回值的类型叫做 `返回类型`, 所有的表达式都可以当做数据使用, 即将表达式（的返回值）作为操作数, 再进行运算。

任何代码都可以看成一个表达式且都有返回值, 甚至单独的一个字符串/数组/数字/变量/变量的声明等.

![image](./assets/return_value.png)

**由此我们可以得出，JS 中的代码是由各种表达式构成，利用表达式的返回值进行运算**

## <font color=#161100 face="黑体">运算符的返回值及类型</font>


### = 运算符

> 该运算符（也可以叫表达式）, 赋什么值就返回什么值, 赋的值的类型是什么返回值的类型就是什么.

```js
var a;
console.log((a = 1)); // 返回值为1
console.log(typeof (a = 1)); // 返回类型为 'number'

// 利用这个特性就可以连续赋值
var b = (c = 1);
// 上面的代码就相当于
//  c = 1 的返回值为 1 再赋值给 b
```

### . 运算符

> 属性访问表达式, 返回属性的值.

### [] 运算符

> 属性访问表达式, 返回属性的值

### () 运算符

> 函数调用表达式, 返回值取决于函数的 return 的值

### console.log()函数

> console.log()函数的返回值为 undefined, 返回值类型为 undefined

```js
console.log(console.log()); //undefined
console.log(typeof console.log()); //undefined
```

### 声明+赋值表达式

> 声明+赋值表达式返回值为 undefined, 类型为 undefined（仅可以在浏览器中测试）, 本质是因为变量声明表达式的返回值为 undefined

Chrome 浏览器的环境是 REPL 环境，Read-Eval-Print-Loop，读-执行-打印-循环，当在浏览器书写代码时，除了会运行代码，还会输出表达式的返回值

## <font color=#161100 face="黑体">算数运算符</font>


### 数学运算符

> +、-、\*、/: 加减乘除

> +、-: 正负

> %: 求余

> ++、--: 自增、自减

> \*\*: 幂运算

#### <font color=red face="黑体">注意事项</font>

    1. 数字的运算是不精确的
    2. 除数为0
        - 被除数为正数，结果为Infinity
        - 被除数为负数，结果为-Infinity
        - 被除数为0，结果为NaN（Not a Number）
    3. 求余(%)：余数的正负与被除数相同
    4. isNaN()用于判断一个数据是否是NaN,返回boolean
    5. isFinite()用于判断一个数据是否是有限的,返回boolean

### 自增/自减运算符

> x++：将变量 x 自增加一，该表达式返回 x 自增之前的值

> ++x：将变量 x 自增加一，该表达式返回 x 自增之后的值

### 比较运算符

> 大小比较

    - 两个字符串比较, 比较的是ascii码

    - 一个字符串与另一个不是字符串的原始值比较, 将二者转换为数字进行比较

    - 一个对象与另一个任意数据类型进行比较，将对象转化为字符串，也就是'[object Object]'

> 相等比较

    普通相等比较（==、!=)
        case1:两边数据类型相同：
            (1). 直接比较, 如果是对象比较地址;
        case2:两边数据类型不相同：
            (1). null等于undefined, 但二者不等于任何数据类型;
            (2). 其他原始类型，转换为数字;
            (3). NaN不等于任何数据类型, 包括自身;
            (4). 对象比较转换为原始类型, 也就是字符串'[object Object]';
    严格相等比较（===、!==）: 比较数据+类型

> 逻辑运算符： && 的优先级高于 ||

### <font color=red face="黑体">注意事项</font>

#### 运算符的优先级

    最高: ++/--
    其次: *、/、% 
    最低: +、- 

#### 优先级的运算细节(容易混淆)

    - 从左到右依次查看
    - 如果遇到操作数，将操作数取出赋值
    - 如果遇到两个相邻的运算符，如果左边的运算符优先级大于等于右边的运算符直接，直接运算左边的表达式

#### 隐式类型转换

> 除+（加号）以外的数学运算符

  **原始类型：将原始类型转化成数字再进行运算**

  boolean : ture ===> 1，false ===> 0

  string：如果内部是一个数字，则转化为对应的数字，如果是一个非数字，转化为 NaN（可识别 Infinity），对于字符串的转换会忽

  两边的空格，空字符串转换为 0

  NaN：NaN 虽然是一个数字但是与任何数字进行转换运算结果都是 NaN

  null：转化为 0

  undefined：转化为 NaN

  **对象类型：将对象类型转化成字符串，在将字符串转换成数字进行运算**

  处理流程：任何对象 => "[object Object]" => NaN

> +（加号）

  规则 1：如果两边都是字符串，加号代表字符串拼接

  规则 2：如果一边是字符串，将不是字符串的一边转化为字符串

  规则 3：如果两边都没有字符串，一边有对象，将对象转换为字符串（'[object Object]'）再按照规则 2 进行转换

  规则 4：其他情况与 " 除加号以外运算符 " 转换的规则一样

### 细节 

> 类型转换不会影响类型本身

- void 运算符：

  作用：运算表达式返回 undefined

  用法：void 表达式 或 void(表达式)

- 逗号运算符

  用法：表达式 1，表达式 2，表达式 3

  作用：依次运行表达式 1，表达式 2，返回表达式 3 的值

### JS 数据未解之谜

> 为什么 JS 小数不精确？

  计算机用二进制进行运算，而十进制小数转化为二进制后，可能是无限循环小数，但计算机的存储能力有限，会丢失一些数据。

> JS 如何存储数据？

  存放数字的方式有两种，整数法和浮点法，而 JS 无论是整数还是小数都用浮点法存放，这也是导致整数计算不一定精确的原因。浮点法存放数据又分为单精度、双精度，而 JS 采用的是双精度 64 位的 IEEE 754 存储标准。
